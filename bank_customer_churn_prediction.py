# -*- coding: utf-8 -*-
"""Bank Customer Churn Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kuZhUpoUwcVwwAY1GAr1tkwGMdtDM3u9

# Bank Customer Churn Prediction

Untuk bisnis di bidang apa pun, penting untuk mempertahankan pelanggan konsisten tetap menggunakan jasa kita agar perusahaan tetap bertahan. Churn adalah jumlah orang yang meninggalkan bisnis pada jangka waktu tertentu. Angka ini menjadi penting ketika melewati ambang batas tertentu.

## Business Understanding

Customer churn merupakan salah satu masalah besar yang dihadapi oleh industri perbankan. Menarik pelanggan baru memerlukan biaya yang jauh lebih tinggi dibandingkan mempertahankan pelanggan yang sudah ada. Oleh karena itu, bank sangat tertarik untuk mengetahui faktor-faktor apa yang menyebabkan pelanggan memutuskan untuk meninggalkan layanan mereka. Dengan memahami alasan di balik churn, bank dapat mengembangkan program loyalitas dan kampanye retensi untuk mempertahankan pelanggan mereka.

Menurut riset oleh Harvard Business Review, perusahaan dengan tingkat retensi pelanggan yang tinggi cenderung lebih sukses dan menguntungkan. Sehingga, prediksi churn dengan akurasi tinggi bisa sangat membantu dalam menyusun strategi retensi yang efektif.

### Problem Statements:
*   Bagaimana cara memprediksi apakah seorang pelanggan akan meninggalkan bank atau tidak berdasarkan data historis pelanggan?
*   Dari beberapa faktor yang ada, faktor apa saja yang paling berpengaruh terhadap keputusan pelanggan untuk pergi dari Bank?


### Goals:

*   Membangun model machine learning yang dapat memprediksi churn pelanggan secara akurat.
*   Mengidentifikasi faktor-faktor utama yang menyebabkan pelanggan pergi dari Bank.

### Solution Statement :

Untuk mencapai tujuan di atas, maka perlu pendekatan solusi yang akan diterapkan sebagai berikut:

* Menggunakan beberapa algoritma untuk memprediksi customer churn secara akurat
* Melakukan improvement pada baseline model dengan hyperparameter tuning.
* Menganalisis data lebih dalam untuk mengetahui faktor apa saja yang mempengaruhi terjadinya customer churn

Solusi akan dievaluasi menggunakan metrik seperti Accuracy, Precision, Recall, dan F1-Score untuk memastikan performa yang optimal.

## Data Understanding
"""

# Commented out IPython magic to ensure Python compatibility.
# Import Libraries

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
# %matplotlib inline

import warnings
warnings.filterwarnings('ignore')

# Load Dataset
df = pd.read_csv("customer_churn.csv")
df.head()

"""#### Deskripsi Variabel

Dataset terdiri dari 14 kolom atau fitur yang memberikan informasi mengenai pelanggan dan perilaku mereka:

* RowNumber — Urutan baris, tidak berpengaruh pada model.
* CustomerId — ID pelanggan (acak, tidak relevan untuk model).
* Surname — Nama belakang pelanggan (tidak berpengaruh pada model).
* CreditScore — Skor kredit pelanggan dalam melunasi kredit, semakin tinggi semakin baik.
* Geography — Lokasi geografis pelanggan, yang mungkin mempengaruhi churn.
* Gender — Jenis kelamin pelanggan, berpotensi memengaruhi perilaku churn.
* Age — Usia pelanggan, di mana pelanggan yang lebih tua cenderung lebih loyal.
* Tenure — Lama pelanggan menjadi nasabah bank.
* Balance — Saldo rekening pelanggan.
* NumOfProducts — Jumlah produk yang dibeli dengan bank tersebut oleh pelanggan.
* HasCrCard — Apakah pelanggan memiliki kartu kredit.
* IsActiveMember — Apakah pelanggan aktif menggunakan layanan bank.
* EstimatedSalary — Gaji yang diperkirakan dari pelanggan.
* Exited — Apakah pelanggan meninggalkan bank (label target).
* Complain — pelanggan mempunyai keluhan atau tidak.
* Satisfaction Score — Skor yang diberikan oleh pelanggan untuk penyelesaian keluhan mereka.
* Card Type — jenis kartu yang dipegang oleh pelanggan.
* Point Earned — poin yang diperoleh pelanggan karena menggunakan kartu kredit.

### Exploratory Data Analysis
"""

df.columns

df.info()

"""Info Dataset

* Terdapat 4 kolom dengan tipe object, yaitu: Surname, Geography, Gender, dan Card Type. Kolom ini merupakan categorical features (fitur non-numerik).
* Terdapat 14 kolom numerik dengan tipe data int64 dan float64 yaitu: RowNumber, CustomerID, CreditScore, Age, Tenure, Balance, NumOfProducts, HasCrCard, IsActiveMember, EstimatedSalary, Exited, Complain, Satisfaction Score, Point Earned.
* Kolom "Exited" adalah target dari prediksi ini.
"""

# Deskripsi Statistik
df.describe()

"""#### Data Cleaning"""

# Hapus kolom yang tidak diperlukan
df.drop(columns=['RowNumber', 'CustomerId', 'Surname'], inplace=True)

# Cek apakah ada nilai kosong
df.isnull().sum()

"""Tidak ada nilai kosong disetiap kolomnya"""

# Cek apakah ada data terduplikat
df.duplicated().sum()

"""Tidak ada data yang terduplikat"""

# Cek apakah ada outliers

# Visualisasi Boxplot
df.plot(
    kind='box',
    subplots=True,
    sharey=False,
    figsize=(30, 7)
)

# increase spacing between subplots
plt.subplots_adjust(wspace=0.5)
plt.show()

"""Pada grafik boxplot di atas, dapat dilihat bahwa terdapat outliers pada kolom age dan creditscore. Akan tetapi, kali ini outliers tidak akan di hapus karena data tersebut masih direntang yang masuk akal dan masih mengandung informasi penting untuk prediksi Customer Churn

#### Univariate Analysis
"""

# Mengklasifikasi kategori fitur
numerical_features = ['CreditScore', 'Age', 'Tenure', 'Balance', 'NumOfProducts', 'HasCrCard', 'IsActiveMember', 'EstimatedSalary', 'Exited', 'Complain', 'Satisfaction Score', 'Point Earned']
categorical_features = ['Geography', 'Gender', 'Card Type']

"""##### Fitur Kategorikal"""

# Fitur Gender
gender = categorical_features[1]
jumlah = df[gender].value_counts()

persentase = 100 * df[gender].value_counts(normalize=True)

data = pd.DataFrame({'jumlah_data':jumlah, 'persentase':persentase.round(1)})
print(data)

jumlah.plot(kind='bar', title=gender)

"""Berdasarkan grafik di atas, customer laki - laki lebih banyak, sekitar 54,6% dari seluruh data, daripada perempuan sebesar 45,4%."""

# Fitur Card Type
card_type = categorical_features[2]
jumlah = df[card_type].value_counts()

persentase = 100 * df[card_type].value_counts(normalize=True)

data = pd.DataFrame({'jumlah_data':jumlah, 'persentase':persentase.round(1)})
print(data)

jumlah.plot(kind='bar', title=card_type)

"""Terdapat 4 kategori tipe kartu yang dimiliki oleh customer, yaitu Diamond, Gold, Silver, Platinum. Masing - masing kategori tersebut memiliki jumlah yang sama yaitu 25% dari jumlah dataset, sekitar 2500 customer untuk masing - masing kategori"""

# Fitur Geography
geography = categorical_features[0]
jumlah = df[geography].value_counts()

persentase = 100 * df[geography].value_counts(normalize=True)

data = pd.DataFrame({'jumlah_data':jumlah, 'persentase':persentase.round(1)})
print(data)

jumlah.plot(kind='bar', title=geography)

"""Dari grafik di atas, dapat dilihat bahwa Bank tersebut banyak yang berasal dari negara France, sekitar 50% dari sampel. Sedangkan sisanya, yaitu berasal dari Germany dan Spain sebanyak 25% dari data untuk masing - masing negara

##### Fitur Numerik
"""

df.hist(bins=50, figsize=(20,15))
plt.show()

"""Dari grafik di atas, maka dapat disimpulkan sebagai berikut :

* Skor pelanggan dalam melunasi kredit berkisar di antara 600 - 700, yang berarti rata - rata nasabah cukup cepat melunasi kredit
* Customer bank tersebut kebanyakan berumur 35 - 40 tahun
* Cukup banyak pelanggan yang tidak memiliki saldo di rekening bank tersebut
* Hampir 50% pelanggan pada sampel sudah tidak aktif menggunakan layanan bank tersebut
* Gaji pelanggan pada bank tersebut cukup variatif dari 0 - 200.000
* 20% pelanggan dari sampel mengeluh dengan bank tersebut.

"""

labels = ['Menetap', 'Pergi']
plt.figure(figsize = (6,6))
plt.pie(x = df['Exited'].value_counts(), labels= labels,
        autopct='%1.1f%%', startangle=90)
plt.title('Churn Distribution')
plt.axis('equal')
plt.show()

"""20% pelanggan dari sampel meninggalkan bank tersebut. Hal ini terhitung cukup besar dan merugikan

#### Multivariate Analysis

##### Fitur Kategorikal
"""

categorical_features = df.select_dtypes(include='object').columns.to_list()
categorical_features = categorical_features[0:3]

categorical_features

plt.figure(figsize = (10, 5))
sns.countplot(data = df, x= categorical_features[0], hue = 'Exited', palette = 'colorblind')
plt.title('Churn by {}'.format(categorical_features[0]))
plt.show()

"""Dari grafik, dapat dilihat bahwa banyak pelanggan yang keluar berasal dari negara German dan France."""

plt.figure(figsize = (10, 5))
sns.countplot(data = df, x= categorical_features[1], hue = 'Exited', palette = 'colorblind')
plt.title('Churn by {}'.format(categorical_features[1]))
plt.show()

# churn rate berdasarkan gender

churn_rate_gender = df.groupby('Gender')['Exited'].mean()*100
print(churn_rate_gender)

"""Dari semua pelanggan perempuan, 25% perempuan memutuskan untuk meninggalkan bank.Dari semua pelanggan laki - laki, 16% meninggalkan bank"""

plt.figure(figsize = (10, 5))
sns.countplot(data = df, x= categorical_features[2], hue = 'Exited', palette = 'colorblind')
plt.title('Churn by {}'.format(categorical_features[2]))
plt.show()

# churn rate berdasarkan Card Type

churn_rate_card_type = df.groupby('Card Type')['Exited'].mean()*100
print(churn_rate_card_type)

"""Sekitar 20% pelanggan dari tiap kategori kartu memutuskan untuk pergi meninggalkan bank

##### Fitur Numerik
"""

# Memilih kolom yang diperlukan
numerical_features = ['CreditScore', 'Age', 'Tenure', 'Balance', 'NumOfProducts', 'HasCrCard', 'IsActiveMember', 'EstimatedSalary', 'Exited', 'Complain', 'Satisfaction Score', 'Point Earned']
len(numerical_features)

# Heatmap
plt.figure(figsize=(10, 6))

correlation_matrix = df[numerical_features].corr().round(2)

# Untuk menge-print nilai di dalam kotak, gunakan parameter anot=True
sns.heatmap(data=correlation_matrix, annot=True, cmap='coolwarm', linewidths=1, )
plt.title("Correlation Matrix untuk Fitur Numerik ", size=20)

"""Jika diperhatikan dengan baik, fitur 'Complain' memiliki skor korelasi dengan target 'Exited' sebesar 1. Artinya, hampir setiap pelanggan yang meninggalkan bank tersebut pasti memiliki keluhan dengan bank tersebut.

Selain itu, adapun fitur 'Age' dan 'Balance' yang memiliki korelasi dengan fitur 'Exited' meskipun korelasi nya rendah. Dapat dikatakan bahwa umur pelanggan dan jumlah saldo rekening pelanggan dapat sedikit mempengaruhi apakah pelanggan meninggalkan bank atau tidak.

Tetapi terdapat fitur 'IsActiveMember' yang berkorelasi negatif dengan fitur 'Exited'. Berarti kedua fitur tersebut berbanding terbalik nilainya meskipun korelasi nya lemah.

Selain fitur tersebut, semua fitur lainnya memiliki korelasi yang kecil. Sehingga tidak diperlukan untuk melakukan prediksi dan dapat dihapus
"""

df.drop(columns=['CreditScore','Tenure','NumOfProducts','HasCrCard','EstimatedSalary','Satisfaction Score','Point Earned'], inplace=True, axis=1)
df.head()

plt.figure(figsize = (8, 6))
sns.countplot(data = df, x= 'IsActiveMember', hue = 'Exited', palette = 'colorblind')
plt.title('Churn by Member Status')
plt.show()

# Churn rate berdasarkan member aktif
churn_rate_active_status = df.groupby('IsActiveMember')['Exited'].mean()*100
print(churn_rate_active_status)

"""Member yang tidak aktif lebih banyak meninggalkan bank daripada yang masih aktif"""

df['AgeGroup'] = pd.cut(df['Age'], bins = [0, 30, 40, 50, 60, np.inf],
                        labels = ['<30', '30-40', '40-50', '50-60', '60+'])
plt.figure(figsize = (8,6))
plt.title('Churn by Age Group')
sns.countplot(data = df, x = 'AgeGroup', hue = 'Exited', palette= 'colorblind')
plt.show()

churn_rate_age = df.groupby('AgeGroup')['Exited'].mean()*100
print(churn_rate_age)

"""Pelanggan dalam kelompok usia 50-60 tahun memiliki tingkat churn tertinggi, yaitu 56.21%. Ini berarti lebih dari separuh pelanggan dalam kelompok usia ini memutuskan untuk meninggalkan bank."""

# Hapus fitur 'AgeGroup' karena tidak terpakai
df.drop(columns='AgeGroup', inplace=True)

"""## Data Preparation

### Encoding Fitur Kategori
"""

from sklearn.preprocessing import OneHotEncoder

for i in categorical_features:
  df = pd.concat([df, pd.get_dummies(df[i], prefix=i, dtype=int)], axis=1)

df.drop(categorical_features, axis=1, inplace=True)
df.head()

df.info()

"""### Handling Imbalance Data

Karena jumlah target ['Exited'] tidak seimbang, maka dilakukan teknik oversampling SMOTE agar target data seimbang
"""

# Oversampling menggunakan SMOTE
from imblearn.over_sampling import SMOTE

x = df.drop(columns='Exited', axis=1)
y = df['Exited']

smote = SMOTE(random_state=42)

x, y = smote.fit_resample(x,y)

y.hist()

"""### Splitting Data"""

from sklearn.model_selection import train_test_split

x_train, x_test, y_train, y_test = train_test_split(x, y, train_size=0.8, random_state=42)

print(f'Total data of sample in whole dataset: {len(x)}')
print(f'Total data of sample in train dataset: {len(x_train)}')
print(f'Total data of sample in test dataset: {len(x_test)}')

"""### Standarisasi

Proses standarisasi mengubah nilai rata-rata (mean) menjadi 0 dan nilai standar deviasi menjadi 1. Hal ini membuat nilai tiap fitur memiliki skala yang sama

Dalam kasus ini:
* Kolom yang memerlukan standarisasi: Age, dan Balance
* Kolom yang tidak memerlukan standarisasi: IsActiveMember, Complain (karena hanya menunjukkan kategori biner).
"""

from sklearn.preprocessing import StandardScaler

numerical_features = ['Age', 'Balance']
scaler = StandardScaler()
scaler.fit_transform(x_train[numerical_features])
x_train[numerical_features] = scaler.transform(x_train.loc[:, numerical_features])
x_train[numerical_features].head()

"""## Modeling"""

# Siapkan dataframe untuk analisis model
models = pd.DataFrame(index=['train_acc', 'test_acc'],
                      columns=['RandomForest', 'Decision Tree', 'XGBoost', 'CatBoost'])

# Buat fungsi untuk membuat model

from sklearn.metrics import classification_report, confusion_matrix, accuracy_score

def train_model(model, x_train=x_train,y_train = y_train, x_test = x_test, y_test = y_test):
    model.fit(x_train, y_train)
    y_pred = model.predict(x_test)


    return (accuracy_score(y_test, y_pred))

"""### Random Forest"""

from sklearn.ensemble import RandomForestClassifier

rf = RandomForestClassifier()
print('Akurasi Prediksi Churn : ', train_model(rf))

"""### Decision Tree"""

from sklearn.tree import DecisionTreeClassifier

dt = DecisionTreeClassifier()
print('Akurasi Prediksi Churn : ', train_model(dt))

"""### XGBoost"""

from xgboost import XGBClassifier

xgb = XGBClassifier()
print('Akurasi Prediksi Churn : ', train_model(xgb))

"""### Catboost"""

# !pip install catboost

from catboost import CatBoostClassifier

cb = CatBoostClassifier(verbose=1000)
print('Akurasi Prediksi Churn : ', train_model(cb))

"""## Evaluasi Model"""

from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score

# Buat variabel accuracy yang isinya adalah dataframe nilai accuracy, precision, recall, dan F1 score pada data train dan test
accuracy = pd.DataFrame(columns=['accuracy', 'precision', 'recall', 'f1'],
                        index=['RandomForest', 'Decision Tree', 'XGBoost', 'CatBoost'])

# Dictionary untuk model yang digunakan
model_dict = {'RandomForest': rf, 'Decision Tree': dt, 'XGBoost': xgb, 'CatBoost': cb}

# Loop melalui setiap model dan hitung metrik evaluasi
for name, model in model_dict.items():
    # Prediksi untuk data test
    y_test_pred = model.predict(x_test)

    # Hitung metrik evaluasi untuk data train dan test
    accuracy.loc[name, 'accuracy'] = accuracy_score(y_true=y_test, y_pred=y_test_pred)
    accuracy.loc[name, 'precision'] = precision_score(y_true=y_test, y_pred=y_test_pred, average='binary').round(3)
    accuracy.loc[name, 'recall'] = recall_score(y_true=y_test, y_pred=y_test_pred, average='binary').round(3)
    accuracy.loc[name, 'f1'] = f1_score(y_true=y_test, y_pred=y_test_pred, average='binary').round(3)

# Tampilkan dataframe accuracy dengan metrik tambahan
accuracy

# Visualisasi Skor Akurasi

fig, ax = plt.subplots()
accuracy.sort_values(by='accuracy', ascending=True).plot(kind='barh', ax=ax, zorder=3)
ax.grid(zorder=0)
plt.legend(loc='best')
plt.tight_layout()
plt.show()

"""Dari grafik akurasi di atas, dapat dilihat bahwa algoritma Random Forest mempunyai skor tertinggi"""

# Buat subplots
fig, axes = plt.subplots(2, 2, figsize=(15, 10))  # 2x2 grid
axes = axes.ravel()  # Flatten the axes array

# Dictionary untuk menampung model dan namanya
model_dict = {'RandomForest': rf, 'Decision Tree': dt, 'XGBoost': xgb, 'CatBoost': cb}

# Loop untuk setiap model dan plot confusion matrix-nya
for idx, (name, model) in enumerate(model_dict.items()):
    # Prediksi menggunakan model
    y_pred = model.predict(x_test)

    # Plot confusion matrix
    sns.heatmap(confusion_matrix(y_test, y_pred), annot=True, fmt='g', ax=axes[idx], cmap="Blues")

    # Beri judul pada setiap subplot
    axes[idx].set_title(f'Confusion Matrix: {name}')
    axes[idx].set_adjustable('box')  # Allow subplot adjustments
    axes[idx].spines['top'].set_visible(True)  # Show top border
    axes[idx].spines['right'].set_visible(True)  # Show right border

# Menambahkan spacing antara subplots
plt.tight_layout()
plt.show()

"""Dari gambar di atas, dapat disimpulkan bahwa model dengan Algoritma Random Forest memiliki hasil skor metrik yang tinggi, dengan penjelasan sebagai berikut :
* Jumlah prediksi benar (True Positive dan True Negative) jauh lebih banyak dibandingkan prediksi salah (False Positive dan False Negative). Ini menunjukkan bahwa model secara keseluruhan mampu mengklasifikasikan data dengan baik.

* Jumlah True Negative sangat tinggi, yang berarti model sangat akurat dalam mengidentifikasi kasus di mana kelas sebenarnya adalah negatif.

* Jumlah True Positive juga cukup tinggi, menunjukkan bahwa model mampu mengidentifikasi sebagian besar kasus di mana kelas sebenarnya adalah positif.

* Jumlah False Positive dan False Negative sangat kecil, mengindikasikan bahwa model jarang melakukan kesalahan dalam mengklasifikasikan data.

## Prediksi
"""

prediksi = x_test.iloc[45:46].copy()
prediksi

"""### Hasil Prediksi"""

prediksi = x_test.iloc[45:46].copy()
pred_dict = {'Label':y_test[45:46]}
pred_dict['Prediksi Model RandomForest'] = model.predict(prediksi)

pd.DataFrame(pred_dict)

"""## Kesimpulan

Dengan demikian, model dengan algoritma Random Forest menjadi solusi model yang dipilih untuk membuat prediksi apakah pelanggan akan meninggalkan bank atau tidak, dengan tingkat akurasi yang sangat baik, dapat dipercaya dan akurat daripada model lainnya.

Faktor - faktor yang mempengaruhi pergi atau tidaknya seorang pelanggan adalah umur, saldo, status member (aktif/tidak aktif), dan yang paling mempengaruhi sekali adalah keluhan pelanggan. Jika pelanggan memiliki keluhan, maka hampir dipastikan pelanggan tersebut akan meninggalkan bank
"""